<link rel="import" href="../polymer/polymer.html">
<script src="../web-animations-js/web-animations.min.js"></script>

<dom-module id="terminal-text">
  <template>
    <style>

      :host {
        display: block;
        --terminal-text-text-color0: #000000;
        --terminal-text-pre-text-color0: #000000;
        --terminal-text-cursor-color0: #000000;
      }

      .cursor {
        color: var(--terminal-text-cursor-color, --terminal-text-cursor-color0);
        font-weight: 600;
      }
      
      .animated-text {
        white-space: pre-wrap;
        color: var(--terminal-text-text-color, --terminal-text-text-color0);
        @apply(--terminal-text-text);
      }

      .pre-text {
        color: var(--terminal-text-pre-text-color, --terminal-text-pre-text-color0);
        font-weight: 600;
        @apply(--terminal-text-pre-text);
      }
    </style>
    <template content="[[_content]]"></template>
    <div><span class="pre-text">[[prefix]]</span><span class="animated-text">[[ nl2br(_output) ]]<span id="cursor" hidden$="[[!showCursor]]" class="cursor">[[cursor]]</span></div>
  </template>

  <script>
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    Polymer({

      is: 'terminal-text',

      properties: {
        _version: {
          type: String,
          readonly: true,
          value: 'v1.0.5'
        }
        /**
         * 	List of strings to output.
         */
        text: {
          type: Array,
          value: ['Lorem\n ipsum alb~3dolor sit amet.','Donec ^1000molestie ultricies velit, tempus.','Etiam quis iaculis nunc, vitae.'],
        },
        /**
         * Minimum delay, in ms, between typing characters.
         */
        typeDelay: {
          type: Number,
          value: 100
        },
        /**
         * Minimum delay, in ms, before clearing characters to resume next.
         */
        clearDelay: {
          type: Number,
          value: 10
        },
        /**
         * Minimum delay, in ms, between deleting characters.
         */
        backDelay: {
          type: Number,
          value: 50
        },
        /**
         * Interval, in ms, that the cursor will flash.
         */
        blinkSpeed: {
          type: Number,
          value: 500,
          observer: '_blinkSpeedChanged'
        },
        /**
         * Character used to represent the cursor.
         */
        cursor: {
          type: String,
          value: 'â–‹'
        },
        /**
         * Time in ms to pause before deleting the current text.
         */
        delay: {
          type: Number,
          value: 2000
        },
        /**
         * Prevent auto delete of the current string and begin outputting the next string.
         */
        preserve: {
          type: Boolean,
          value: false
        },
        /**
         * Begin each string with this prefix value.
         */
        prefix: {
          type: String,
          value: '[terminal-text ~]# '
        },
        /**
         * Number of times to loop through the output strings, for unlimited use 0.
         */
        loop: {
          type: Number,
          value: 0
        },
        /**
         * Add a random delay before each character to represent human interaction.
         */
        humanize: {
          type: Boolean,
          value: false
        },
        /**
         * Blink the cursor.
         */
        blink: {
          type: Boolean,
          value: true
        },
        /**
         * Show the cursor leading the text.
         */
        showCursor: {
          type: Boolean,
          value: true
        },

        _current: {
          type: Object,
          value: {
            string: '',
            index: 0,
            position: 0,
            loop: 0
          }
        },
        value: {
          type: String,
          value: '',
          notify: true
        },
        _output: {
          type: String,
          value: '',
          observer: '_outputChanged'
        },
        _cursorAnimation: {
          type: Object,
          value: {}
        }
      },
      nl2br: function(txt) {
        return txt; //txt.replace(/\n/, '<br />');
      },
      _next: function() {
        this._current.index++;
        if ( this._current.index >= this.text.length ) {
          this._current.index = 0;
          this._current.loop++;
          if ( this.loop !== false && ( this.loop == this._current.loop ) ) {
            return false;
          }
        }
        this._current.position = 0;
        this._setCurrentString(this);
        if ( typeof( this.callbackNext ) == 'function' ) {
          this.callbackNext( this._current, object );
        }
        return true;        
      },
      _isNumeric: function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      },
      _type: function() {
        var letters = this._current.string.split( '' ),
          letter = letters[this._current.position],
          start = this._current.position + 1;
        if ( letter == '^' || letter == '~' ) {
          var end = this._current.string.substr( start ).search( /[^0-9]/ );
          if ( end == -1 ) {
            end = this._current.string.length;
          }
          var value = this._current.string.substr( start, end );
          if ( this._isNumeric( value ) ) {
            this._current.string = this._current.string.replace( letter + value, '' );
            if ( letter == '^' ) {
              this.async( function() {
                this.async( function() {
                  this._type();
                }, this._delay( this.typeDelay ) );
              }, value );
            } else {
              var index = this._current.position - value;
              this._current.string = this._current.string.substr( 0, index - 1 ) + this._current.string.substr( this._current.position - 1 );
              this.async( function() {
                this._backspace( Math.max( index, 0 ) );
              }, this._delay( this.backDelay ) );
            }
            return;
          }
        }
        if ( letter == '|' ) {
          var value = this._current.string.substr( start, 1 );
          this.cursor = value;
          this._current.string = this._current.string.replace( letter + value , '' );
          this._type();
          return;
        }
        if ( letter !== undefined ) {
          this._output = this._output + letter;
        }
        this._current.position++;
        if ( this._current.position < this._current.string.length ) {
          this.async( function() { this._type(); }, this._delay( this.typeDelay ) );
        } else if ( this.preserve === false ) {
          this.async( function() {
            this.async( function() { this._backspace(); }, this._delay( this.backDelay ) );
          }, this.delay );
        } else {
          if ( this._next() ) {
            this.async( function() {
              this._output = '';
              this._type();
            }, this.clearDelay );
          } else if ( typeof( this.callbackFinished ) == 'function' ) {
            this.callbackFinished( object );
          }
        }
        if ( typeof( this.callbackType ) == 'function' ) {
          this.callbackType( letter, this._current, object );
        }
      },
      _backspace: function(stop) {
        if ( !stop ) {
          stop = 0;
        }
        if ( this._current.position > stop ) {
          this._output = this._output.slice(0, -1);
          this.async( function() {
            this._backspace( stop );
          }, this._delay( this.backDelay ) );
          this._current.position--;
        } else {
          if ( stop === 0 ) {
            if ( this._next(this) === false ) {
              return;
            }
          }
          this.async( function() { 
            this._type(); 
          }, this._delay( this.typeDelay ) );
        }
      },
      _delay: function(speed) {
        var time = parseInt( speed );
        if ( this.humanize ) {
          time += Math.floor( Math.random() * 200 );
        }
        return time;
      },
      _setCurrentString: function() {
        if (!!this.text) {
          this._current.string = this.text[this._current.index]; // .replace(/\n/g, "\\n");
        }
      },
      _animateCursor: function() {
        if (!!!this._cursorAnimation || !!!this._cursorAnimation.playState) {
          var elem = this.$.cursor;
          this._cursorAnimation = elem.animate({
            opacity: [0, 1],
            transform: ['scale(0.5)', 'scale(1)'],
          }, {
            direction: 'alternate',
            duration: this.blinkSpeed,
            iterations: Infinity,
          });
        }
        this._cursorAnimation.play();
      },
      ready: function() {
        this._setCurrentString();
        this._type();
        if (this.blink) {
          this._animateCursor();
        }
      },
      _cursorClass: function(b) {
        return b ? 'blink_me' : 'no-blink';
      },
      _blinkChanged: function(b){
        if (!!!b && !!this._cursorAnimation) {
          this._cursorAnimation.pause();
          this._cursorAnimation.currentTime = this.blinkSpeed;
          return;
        }
        if (!!b) {
          this._animateCursor();
        }
      },
      _blinkSpeedChanged: function(n, o){
        if (!!n && !!this._cursorAnimation) {
          this._cursorAnimation.cancel();
          this._cursorAnimation = null;
          this._animateCursor();
        }
      },
      _outputChanged: function(n) {
        this.value = n;
      },
      observers: [
        '_blinkChanged(blink)'
      ]
    });
  </script>
</dom-module>
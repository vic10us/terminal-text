<link rel="import" href="../polymer/polymer.html">

<dom-module id="terminal-text">
  <template>
    <style>

      :host {
        --terminal-text-cursor: { 
          color: black;
        };

        --terminal-text-pre-text: {
          color: black;
          font-weight: 600;
        };
      }

      .cursor {
        color: darkgreen;
      }
      
      .blink_me {
        -webkit-animation: blink 0.75s linear infinite;
        -moz-animation: blink 0.75s linear infinite;
        -ms-animation: blink 0.75s linear infinite;
        -o-animation: blink 0.75s linear infinite;
        animation: blink 0.75s linear infinite;
        opacity: 1;
        will-change: opacity;
      }

      .pre-text {
        color: darkgreen;
        @apply(--terminal-text-pre-text);
      }

      @keyframes "blink" {
        50% { opacity: 0; }
      }

      @-moz-keyframes blink {
        50% { opacity: 0; }
      }

      @-webkit-keyframes "blink" {
        50% { opacity: 0; }
      }

      @-ms-keyframes "blink" {
        50% { opacity: 0; }
      }

      @-o-keyframes "blink" {
        50% { opacity: 0; }
      }
    </style>
    <div><span class="pre-text">[[prefix]]</span><span class="animated-text">[[_output]]<span hidden$="[[!showCursor]]" class$="cursor [[_cursorClass(blink)]]">[[cursor]]</span></div>
  </template>

  <script>
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    Polymer({

      is: 'terminal-text',

      properties: {
        text: {
          type: Array,
          value: ['one','two','three'],
        },
        typeDelay: {
          type: Number,
          value: 100
        },
        backDelay: {
          type: Number,
          value: 50
        },
        blinkSpeed: {
          type: Number,
          value: 1000
        },
        delay: {
          type: Number,
          value: 2000
        },
        preserve: {
          type: Boolean,
          value: false
        },
        backDelay: {
          type: Number,
          value: 50
        },
        prefix: {
          type: String,
          value: '[terminal-text ~]# '
        },
        loop: {
          type: Number,
          value: 0
        },
        humanize: {
          type: Boolean,
          value: true
        },
        smoothBlink: {
          type: Boolean,
          value: true
        },
        cursor: {
          type: String,
          value: 'â–‹'
        },
        blink: {
          type: Boolean,
          value: true
        },
        showCursor: {
          type: Boolean,
          value: true
        },
        _current: {
          type: Object,
          value: {
            string: '',
            index: 0,
            position: 0,
            loop: 0
          }
        },
        _output: {
          type: String,
          value: ''
        }
      },
      _next: function() {
        this._current.index++;
        if ( this._current.index >= this.text.length ) {
          this._current.index = 0;
          this._current.loop++;
          if ( this.loop !== false && ( this.loop == this._current.loop ) ) {
            return false;
          }
        }
        this._current.position = 0;
        this._setCurrentString(this);
        if ( typeof( this.callbackNext ) == 'function' ) {
          this.callbackNext( this._current, object );
        }
        return true;        
      },
      _isNumeric: function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      },
      _type: function() {
        var letters = this._current.string.split( '' ),
          letter = letters[this._current.position],
          start = this._current.position + 1;
        if ( letter == '^' || letter == '~' ) {
          var end = this._current.string.substr( start ).search( /[^0-9]/ );
          if ( end == -1 ) {
            end = this._current.string.length;
          }
          var value = this._current.string.substr( start, end );
          if ( this._isNumeric( value ) ) {
            this._current.string = this._current.string.replace( letter + value, '' );
            if ( letter == '^' ) {
              this.async( function() {
                this.async( function() {
                  this._type();
                }, this._delay( this.typeDelay ) );
              }, value );
            } else {
              var index = this._current.position - value;
              this._current.string = this._current.string.substr( 0, index - 1 ) + this._current.string.substr( this._current.position - 1 );
              this.async( function() {
                this._backspace( Math.max( index, 0 ) );
              }, this._delay( this.backDelay ) );
            }
            return;
          }
        } else if ( letter == '\\' ) {
          var nextChar = this._current.string.substr( start, 1 );
          if ( nextChar == 'n' ) {
            this._current.position++;
            letter = '<br />';
          }
        }
        if ( letter !== undefined ) {
          // output.html( output.html() + letter );
          this._output = this._output + letter;
        }
        this._current.position++;
        if ( this._current.position < this._current.string.length ) {
          this.async( function() { this._type(); }, this._delay( this.typeDelay, this ) );
        } else if ( this.preserve === false ) {
          this.async( function() {
            this.async( function() { this._backspace(0) }, this._delay( this.backDelay, this ) );
          }, this.delay );
        } else {
          this._output = '';
          // output.html( output.html() + '<span class="teletype-prefix">' + this.prefix + '</span>' );
          if ( next() ) {
            this.async( function() {
              this.async( function() { this._type(); }, this._delay( this.typeDelay, this ) );
            }, this.delay );
          } else if ( typeof( this.callbackFinished ) == 'function' ) {
            this.callbackFinished( object );
          }
        }
        if ( typeof( this.callbackType ) == 'function' ) {
          this.callbackType( letter, this._current, object );
        }
      },
      _backspace: function(stop) {
        if ( !stop ) {
          stop = 0;
        }
        if ( this._current.position > stop ) {
          this._output = this._output.slice(0, -1);
          // output.html( output.html().slice( 0, -1 ) );
          this.async( function() {
            this._backspace( stop );
          }, this._delay( this.backDelay ) );
          this._current.position--;
        } else {
          if ( stop === 0 ) {
            if ( this._next(this) === false ) {
              return;
            }
          }
          this.async( function() { 
            this._type(); 
          }, this._delay( this.typeDelay ) );
        }
      },
      _delay: function(speed, t) {
        var time = parseInt( speed );
        if ( this.humanise ) {
          time += Math.floor( Math.random() * 200 );
        }
        return time;
      },
      _setCurrentString: function() {
        this._current.string = this.text[this._current.index].replace(/\n/g, "\\n");
      },
      ready: function() {
        this._setCurrentString();
        this._type();
      },
      _cursorClass: function(b) {
        return b ? 'blink_me' : 'no-blink';
      }
    });
  </script>
</dom-module>